from ase.io.trajectory import Trajectory
from numpy import square, sum, asarray
from ase import units

# Settings to change
input_file = "moldyn_nvt.traj"
timestep = 5 # fs
steps_between_saved_images = 10 # How often the .traj is written 
ignore_N_images = 50 # ignore non-converged data, just needed for testing. Set to 0 for pre-converged system

# Diffusion coefficients worked out as per these pages: 
# - http://www.cs.unc.edu/Research/nbody/pubs/external/Keffer/selfD.pdf
# - https://docs.quantumwise.com/_downloads/diffusion_liquid_copper.pdf
# - https://ws680.nist.gov/publication/get_pdf.cfm?pub_id=831759
# This is the Einstein equation, as per https://en.wikibooks.org/wiki/Molecular_Simulation/Diffusion_Coefficients
# Example diffusion coefficients available from literature here: https://en.wikipedia.org/wiki/Mass_diffusivity#Solids

total_ensemble_averages = []
xyz_ensemble_averages = [[] for i in range(3)] 
traj = Trajectory(input_file)
time_between_images = timestep*steps_between_saved_images

# Currently this is only atom averaged
# As per http://www.cs.unc.edu/Research/nbody/pubs/external/Keffer/selfD.pdf, this deals 
# with x, y and z directions independently so we can get statistical data (standard deviation, etc.)

# for testing, ignore non-converged data
for i in range(ignore_N_images+1,len(traj)):
    xyz_ensemble_average = [0.0]*3
    
    # Sum square of displacements
    for j in range(len(traj[i])):
        for xyz in range(3):
            xyz_ensemble_average[xyz] += square(traj[i].positions[j][xyz] - traj[ignore_N_images].positions[j][xyz])

    for xyz in range(3):
        xyz_ensemble_averages[xyz].append(sum(xyz_ensemble_average[xyz])/(len(traj[i])*2)) # Divide by N atoms and 2N degrees of freedom

    total_ensemble_averages.append(sum(xyz_ensemble_average)/(len(traj[i])*6)) # Divide by N atoms and 2N degrees of freedom 

# Timesteps is just the range over which we analyse the data. For now, this is the whole data span sampled
timesteps = list(range((ignore_N_images+1) * time_between_images, len(traj) * time_between_images, time_between_images))

# Analyse data
import matplotlib.pyplot as plt
from scipy import stats

def fit_data_and_plot(x, y, plt, color, label):
    # Generated linear fit
    slope, intercept, r_value, p_value, std_err = stats.linregress(x,y)
    line = slope*asarray(x)+intercept

    plt.plot(x, y, color=color, marker='s', linewidth=0)
    plt.plot(x, line, color=color)

    # print(r'Intercept = %.10f $\AA^2$; Diffusion Coefficient = %.10f $\AA^2$/fs' % (intercept, slope))
    # Converting to more common units of cm^2/s => multiply by 10^-1
    # \AA^2 => cm^2 requires multiplying by (10^-8)^-2
    # fs => s requires dividing by 10^-15
    print(r'%10s: Intercept = %.10f cm^2; Diffusion Coefficient = %.10f cm^2/s, %.10f m^2/s' % (label, intercept/(10**8), slope*(0.1), slope*(10**-5)))

    return slope

slopes = []
slopes.append(fit_data_and_plot(timesteps, xyz_ensemble_averages[0], plt, 'lightcoral', 'X'))
slopes.append(fit_data_and_plot(timesteps, xyz_ensemble_averages[1], plt, 'lightgreen', 'Y'))
slopes.append(fit_data_and_plot(timesteps, xyz_ensemble_averages[2], plt, 'lightblue', 'Z'))

fit_data_and_plot(timesteps, total_ensemble_averages, plt, 'k', 'Total data')

from statistics import mean, stdev
print('---')
print(r'Mean Diffusion Coefficient (X, Y and Z) = %.10f cm^2/s, %.10f m^2/s; Standard Deviation = %.10f cm^2/s, %.10f m^2/s' % (mean(slopes)*(0.1), mean(slopes)*(10**-5), stdev(slopes)*(0.1), stdev(slopes)*(10**-5)))
print('---')

plt.xlabel('Time (fs)')
plt.ylabel(r'Diffusion ($\AA^2$)')
plt.show()
