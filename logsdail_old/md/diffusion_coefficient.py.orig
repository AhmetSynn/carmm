from ase.io.trajectory import Trajectory
from numpy import square, sum, asarray
from ase import units

# Settings to change
input_file = "moldyn_nvt.traj"
timestep = 5 # fs
steps_between_saved_images = 10 # How often the .traj is written 
ignore_N_images = 50 # ignore non-converged data, just needed for testing. Set to 0 for pre-converged system

# Diffusion coefficients worked out as per these pages: 
# - http://www.cs.unc.edu/Research/nbody/pubs/external/Keffer/selfD.pdf
# - https://docs.quantumwise.com/_downloads/diffusion_liquid_copper.pdf
# - https://ws680.nist.gov/publication/get_pdf.cfm?pub_id=831759
# This is the Einstein equation, as per https://en.wikibooks.org/wiki/Molecular_Simulation/Diffusion_Coefficients
# Example diffusion coefficients available from literature here: https://en.wikipedia.org/wiki/Mass_diffusivity#Solids

total_ensemble_averages = []
traj = Trajectory(input_file)
time_between_images = timestep*steps_between_saved_images

# Currently this is only atom averaged
# As per http://www.cs.unc.edu/Research/nbody/pubs/external/Keffer/selfD.pdf, it'd be good to time average this also
# and that is something for us to do in the immediate future when we have time.
# It would also be ideal to x, y and z directions independently so we can get statistical data (standard deviation, etc.)

# for testing, ignore non-converged data
for i in range(ignore_N_images+1,len(traj)):
    ensemble_average = 0.0
    
    # Sum square of displacements
    for j in range(len(traj[i])):
        ensemble_average += sum(square(traj[i].positions[j] - traj[ignore_N_images].positions[j]))

    # Work out average if displacements
    ensemble_average /= len(traj[i])

    # Print out Diffusion Coefficient: 
    # Angstrom = 10^-10 m; Femtosecond = 10^-15 s
    # print('Time = %.1f fs; Diffusion Coefficient = %3.3f \AA^2/fs' % (i*time_between_images, ensemble_average/(i*time_between_images)))

    total_ensemble_averages.append(ensemble_average/6) # 6 is due to 3 dimensions of mobility

# Timesteps is just the range over which we analyse the data. For now, this is the whole data span sampled
timesteps = list(range((ignore_N_images+1) * time_between_images, len(traj) * time_between_images, time_between_images))

# Analyse data
import matplotlib.pyplot as plt
from scipy import stats

plt.plot(timesteps,total_ensemble_averages,'rs')
plt.xlabel('Time (fs)')
plt.ylabel(r'Diffusion ($\AA^2$)')

# Generated linear fit
slope, intercept, r_value, p_value, std_err = stats.linregress(timesteps,total_ensemble_averages)
line = slope*asarray(timesteps)+intercept

plt.plot(timesteps,total_ensemble_averages,'o', timesteps, line)

print(r'Intercept = %.10f $\AA^2$; Diffusion Coefficient = %.10f $\AA^2$/fs' % (intercept, slope))
# Converting to more common units of cm^2/s => multiply by 10^-1
# \AA^2 => cm^2 requires multiplying by (10^-8)^-2
# fs => s requires dividing by 10^-15
print(r'Intercept = %.10f cm^2; Diffusion Coefficient = %.10f cm^2/s, %.10f m^2/s' % (intercept/(10**8), slope*(0.1), slope*(10**-5)))
plt.show()
