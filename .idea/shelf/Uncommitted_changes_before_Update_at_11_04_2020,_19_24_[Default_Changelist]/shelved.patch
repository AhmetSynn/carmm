Index: analyse/bonds.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>import numpy as np\nfrom ase.io import read\nfrom ase.geometry.analysis import Analysis\n\n\ndef analyse_all_bonds(model):\n    '''\n    Returns a table of bond distance analysis for the supplied model.\n            model: Atoms object or string. If string it will read a file\n            in the same folder, e.g. \"name.traj\"\n    '''\n    # Combination as AB = BA for bonds, avoiding redundancy\n    from itertools import combinations_with_replacement\n\n    # Read file or Atoms object\n    if isinstance(model, str) is True:\n        model = read(model)\n\n    analysis = Analysis(model)\n    dash = \"-\" * 40\n\n    # set() to ensure unique chemical symbols list\n    list_of_symbols = list(set(model.get_chemical_symbols()))\n    all_bonds = combinations_with_replacement(list_of_symbols, 2)\n\n    # Table heading\n    print(dash)\n    print('{:<6.5s}{:<6.5s}{:>4.10s}{:^13.10s}{:>4.10s}'.format(\n        \"Bond\", \"Count\", \"Average\", \"Minimum\", \"Maximum\"))\n    print(dash)\n\n    # Iterate over all arrangements of chemical symbols\n    for bonds in all_bonds:\n        A = bonds[0]\n        B = bonds[1]\n\n        print_AB = A+'-'+B\n        AB_Bonds = analysis.get_bonds(A, B)\n\n        # Make sure bond exist before retrieving values, then print contents\n        if not AB_Bonds == [[]]:\n            AB_BondsValues = analysis.get_values(AB_Bonds)\n            print('{:<8.8s}{:<6.0f}{:>4.6f}{:^12.6f}{:>4.6f}'.format(\n                print_AB, len(AB_BondsValues[0]), np.average(AB_BondsValues),\n                np.amin(AB_BondsValues), np.amax(AB_BondsValues)))\n\n\ndef analyse_all_angles(model):\n    '''\n    Returns a table of bond angle analysis for the supplied model.\n            model: Atoms object or string. If string it will read a file\n            in the same folder, e.g. \"name.traj\"\n    '''\n\n    # Product to get all possible arrangements\n    from itertools import product\n    # Read file or Atoms object\n    if isinstance(model, str) is True:\n        model = read(model)\n\n    analysis = Analysis(model)\n    dash = \"-\" * 40\n    # set() to ensure unique chemical symbols list\n    list_of_symbols = list(set(model.get_chemical_symbols()))\n    all_angles = product(list_of_symbols, repeat=3)\n\n    # Table heading\n    print(dash)\n    print('{:<9.8s}{:<6.5s}{:>4.10s}{:^13.10s}{:>4.10s}'.format(\n        \"Angle\", \"Count\", \"Average\", \"Minimum\", \"Maximum\"))\n    print(dash)\n\n    # Iterate over all arrangements of chemical symbols\n    for angles in all_angles:\n        A = angles[0]\n        B = angles[1]\n        C = angles[2]\n\n        print_ABC = A+'-'+B+'-'+C\n        ABC_Angle = analysis.get_angles(A, B, C)\n\n        # Make sure angles exist before retrieving values, print table contents\n        if not ABC_Angle == [[]]:\n            ABC_AngleValues = analysis.get_values(ABC_Angle)\n            print('{:<9.8s}{:<6.0f}{:>4.4f}{:^12.4f}{:>4.4f}'.format(\n                print_ABC, len(ABC_Angle[0]), np.average(ABC_AngleValues),\n                np.amin(ABC_AngleValues), np.amax(ABC_AngleValues)))\n\n\ndef analyse_bonds(model, A, B):\n    '''\n    Check A-B distances present in the model.\n        model: Atoms object or string. If string it will read a file\n        in the same folder, e.g. \"name.traj\"\n        A: string, chemical symbol, e.g. \"H\"\n        B: string, chemical symbol, e.g. \"H\"\n    '''\n    # Read file or Atoms object\n    if isinstance(model, str) is True:\n        model = read(model)\n\n    analysis = Analysis(model)\n    dash = \"-\" * 40\n    print_AB = A + \"-\" + B\n    # Retrieve bonds and values\n    AB_Bonds = analysis.get_bonds(A, B)\n    AB_BondsValues = analysis.get_values(AB_Bonds)\n    # Table header\n    print(dash)\n    print(print_AB+\"       Distance / Angstrom\")\n    print(dash)\n    print('{:<6.5s}{:>4.10s}{:^13.10s}{:>4.10s}'.format(\n        \"count\", \"average\", \"minimum\", \"maximum\"))\n    # Table contents\n    print('{:<6.0f}{:>4.6f}{:^12.6f}{:>4.6f}'.format(\n        len(AB_BondsValues[0]), np.average(AB_BondsValues),\n        np.amin(AB_BondsValues), np.amax(AB_BondsValues)))\n\n\ndef analyse_angles(model, A, B, C):\n    '''\n    Check A-B distances present in the model.\n        model: Atoms object or string. If string it will read a file\n        in the same folder, e.g. \"name.traj\"\n        A: string, chemical symbol, e.g. \"O\"\n        B: string, chemical symbol, e.g. \"C\"\n        C: string, chemical symbol, e.g. \"O\"\n    '''\n    # Read file or Atoms object\n    if isinstance(model, str) is True:\n        model = read(model)\n\n    analysis = Analysis(model)\n    dash = \"-\"*40\n    print_ABC = A + \"-\" + B + \"-\" + C\n    # Retrieve bonds and values\n    ABC_Angle = analysis.get_angles(A, B, C)\n    ABC_AngleValues = analysis.get_values(ABC_Angle)\n    # Table header\n    print(dash)\n    print(print_ABC+\"       Angle / Degrees\")\n    print(dash)\n    print('{:<6.5s}{:>4.10s}{:^13.10s}{:>4.10s}'.format(\n        \"count\", \"average\", \"minimum\", \"maximum\"))\n    # Table contents\n    print('{:<6.0f}{:>4.4f}{:^12.4f}{:>4.4f}'.format(\n        len(ABC_Angle[0]), np.average(ABC_AngleValues),\n        np.amin(ABC_AngleValues), np.amax(ABC_AngleValues)))\n\n\ndef search_abnormal_bonds(model, verbose=True):\n    '''\n    Check all bond lengths in the model for abnormally\n    short ones, ie. less than 0.74 Angstrom.\n        model: Atoms object or string. If string it will read a file\n        in the same folder, e.g. \"name.traj\"\n    '''\n\n    # Combination as AB = BA for bonds, avoiding redundancy\n    from itertools import combinations_with_replacement\n    # Imports necessary to work out accurate minimum bond distances\n    from ase.data import chemical_symbols, covalent_radii\n\n    # Read file or Atoms object\n    if isinstance(model, str) is True:\n        model = read(model)\n\n    # Define lists of variables\n    abnormal_bonds = []\n    list_of_abnormal_bonds = []\n\n    analysis = Analysis(model)\n    # set() to ensure unique chemical symbols list\n    list_of_symbols = list(set(model.get_chemical_symbols()))\n    all_bonds = combinations_with_replacement(list_of_symbols, 2)\n\n    # Iterate over all arrangements of chemical symbols\n\n    for bonds in all_bonds:\n        A = bonds[0]\n        B = bonds[1]\n        # For softcoded bond cutoff\n        sum_of_covalent_radii = covalent_radii[chemical_symbols.index(A)]+covalent_radii[chemical_symbols.index(B)]\n\n        print_AB = A+'-'+B\n        AB_Bonds = analysis.get_bonds(A, B)\n\n        # Make sure bond exist before retrieving values\n        if not AB_Bonds == [[]]:\n            AB_BondsValues = analysis.get_values(AB_Bonds)\n\n            for i in range(0, len(AB_BondsValues)):\n                for values in AB_BondsValues[i]:\n                    # TODO: move the 75% of sum_of_covalent_radii before the loops\n                    if values < max(0.4, sum_of_covalent_radii*0.75):\n                        abnormal_bonds += [1]\n                        list_of_abnormal_bonds = list_of_abnormal_bonds + [print_AB]\n\n    # Abnormality check\n    # is it possible to make a loop with different possible values instead of 0.75 and takes the average\n    if len(abnormal_bonds) > 0:\n        if verbose:\n            print(\"A total of\", len(abnormal_bonds),\n            \"abnormal bond lengths observed (<\" + str(max(0.4, sum_of_covalent_radii*0.75)) + \" A).\")\n            print(\"Identities:\", list_of_abnormal_bonds)\n        return False\n    else:\n        if verbose:\n            print(\"OK\")\n        return True\n\ndef get_indices_of_elements(list_of_symbols, symbol):\n    return [i for i, x in enumerate(list_of_symbols) if x == symbol.capitalize()]\n\n\n'''\n## not working as intended as specific indices are needed\ndef analyse_dihedrals(model):\n    from itertools import product\n    if isinstance(model, str) is True: #read file or Atoms object\n        model = read(model)\n\n    analysis = Analysis(model)\n    dash = \"-\"*40\n    list_of_symbols = list(set(model.get_chemical_symbols())) #set to ensure unique chemical symbols list\n    all_angles = product(list_of_symbols, repeat=4)\n\n    print(dash)     #Table heading\n    print('{:<6.5s}{:<6.5s}{:>4.10s}{:^13.10s}{:>4.10s}'.format(\"Angle\",\"Count\",\"Average\", \"Minimum\", \"Maximum\"))\n    print(dash)\n\n    for angles in all_angles:     #iterate over all arrangements of chemical symbols\n        A = angles[0]\n        B = angles[1]\n        C = angles[2]\n        D = angles[3]\n\n        print_ABC = A+'-'+B+'-'+C+'-'+D\n        ABC_Angle = analysis.get_dihedrals(A,B,C,D)\n\n        if not ABC_Angle == [[]]:   #make sure angles exist before retrieving values\n            ABC_AngleValues = analysis.get_values(ABC_Angle)\n            print('{:<6.8s}{:<6.0f}{:>4.4f}{:^12.4f}{:>4.4f}'.format(\n            print_ABC,len(ABC_Angle[0]), np.average(ABC_AngleValues),np.amin(ABC_AngleValues),np.amax(ABC_AngleValues)))\n'''\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- analyse/bonds.py	(revision 0f11504e784209655f208c92a5a061c7e46a202e)
+++ analyse/bonds.py	(date 1586629233152)
@@ -209,10 +209,43 @@
             print("OK")
         return True
 
+
+def compare_structures(atoms1, atoms2, cutoff=0.01):
+
+    from math import sqrt
+
+    if len(atoms1) != len(atoms2):
+        print("The inputs don't contain the same number of atoms.")
+        exit()
+
+    # Configure arrays
+    differences = []
+    atoms2_indices = []
+    # Iterate over indices of all atoms in structure 1 and compare to structure 2.
+    for i in range(len(atoms1.positions)):
+        xyz = atoms1.positions[i]
+        distance_sq = 999999.9
+        temp_index = 0
+        for j in range(len(atoms2.positions)):
+            temp_distance_sq = ((atoms2.positions[j][0] - xyz[0]) * (atoms2.positions[j][0] - xyz[0])
+                                + (atoms2.positions[j][1] - xyz[1]) * (atoms2.positions[j][1] - xyz[1])
+                                + (atoms2.positions[j][2] - xyz[2]) * (atoms2.positions[j][2] - xyz[2]))
+
+            if distance_sq > temp_distance_sq and \
+                    atoms1.symbols[i] == atoms2.symbols[j]:
+                distance_sq = temp_distance_sq
+                temp_index = j
+
+        atoms2_indices.append(temp_index)
+        differences.append(sqrt(distance_sq))
+
+    return atoms2_indices, differences
+
 def get_indices_of_elements(list_of_symbols, symbol):
     return [i for i, x in enumerate(list_of_symbols) if x == symbol.capitalize()]
 
 
+
 '''
 ## not working as intended as specific indices are needed
 def analyse_dihedrals(model):
Index: examples/build_NEB.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>#!/usr/bin/env python3\n\nfrom software.build.neb import switch_indices, check_interpolation\nfrom ase.build import molecule\n\ninitial = molecule(\"CO2\")\nfinal = molecule(\"CO2\")\n\n#check_interpolation('initial.traj','final.traj',10)\n#### Assertion tests ####\nassert(check_interpolation(initial, final, 10, verbose=False, save=False))\n########\n\natom_to_swap = 1\nother_atom_to_swap = 2\n\n#updated_final = switch_indices('final.traj', atom_to_swap, other_atom_to_swap):\nupdated_final = switch_indices(final, atom_to_swap, other_atom_to_swap)\n\n#### Assertion tests ####\nassert(not check_interpolation(initial, updated_final, 10, verbose=False, save=False))\n########
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- examples/build_NEB.py	(revision 0f11504e784209655f208c92a5a061c7e46a202e)
+++ examples/build_NEB.py	(date 1586629375555)
@@ -1,6 +1,7 @@
 #!/usr/bin/env python3
 
 from software.build.neb import switch_indices, check_interpolation
+from software.analyse.bonds import compare_structures
 from ase.build import molecule
 
 initial = molecule("CO2")
@@ -19,4 +20,14 @@
 
 #### Assertion tests ####
 assert(not check_interpolation(initial, updated_final, 10, verbose=False, save=False))
+########
+
+#### Functionality to identify indices that would need swapping automatically
+indices_to_swap, distances = compare_structures(initial, updated_final)
+for i in range(len(indices_to_swap)):
+    if indices_to_swap[i] is not i:
+        reupdated_final = switch_indices(updated_final, i, indices_to_swap[i])
+
+#### Assertion tests ####
+assert(check_interpolation(initial, reupdated_final, 10, verbose=False, save=False))
 ########
\ No newline at end of file
Index: analyse/compare_structures.py
===================================================================
--- analyse/compare_structures.py	(revision 0f11504e784209655f208c92a5a061c7e46a202e)
+++ analyse/compare_structures.py	(revision 0f11504e784209655f208c92a5a061c7e46a202e)
@@ -1,61 +0,0 @@
-#!/usr/bin/python3
-
-from ase.io import read
-import sys
-
-def print_non_zeros(square_distances, indices, filter_distance=0.0):
-    from math import sqrt
-
-    distances = []
-    print("Filtering print-out for distances greater than ", sqrt(filter_distance), " \AA")
-    for i in range(len(square_distances)):
-        if square_distances[i] > 0.0:
-            distances.append(sqrt(square_distances[i]))
-            if square_distances[i] > filter_distance:
-                print("Index structure 1: ", i, "; Index structure 2: ", indices[i], "; Difference: ", distances[-1])
-    print("")
-    print("RMSD (non-zero differences): ", sum(distances)/len(distances))
-            
-
-if len(sys.argv) < 3:
-    print("Please provide at least two sturcture files")
-    exit()
-
-structure_one = read(sys.argv[1])
-structure_two = read(sys.argv[2])
-try:
-    filter_cutoff = float(sys.argv[3])*float(sys.argv[3])
-except:
-    filter_cutoff = 0.01
-     
-if len(structure_one) != len(structure_two):
-    print("The inputs don't contain the same number of atoms. How do you expect to compare them sensibly?")
-    exit()
-
-## Sadly, this doesn't work if the inputs are structured differently
-#diff_positions = structure_two.positions - structure_one.positions
-#
-##print(diff_positions)
-square_deviations = []
-#for xyz in diff_positions:
-#    square_deviations.append((xyz[0]*xyz[0])+(xyz[1]*xyz[1])+(xyz[2]*xyz[2]))
-
-structure_two_indices = []
-for i in range(len(structure_one.positions)):
-    xyz = structure_one.positions[i]
-    distance_square = 999999
-    temp_index = 0
-    for j in range(len(structure_two.positions)):
-        temp_distance_square = ((structure_two.positions[j][0]-xyz[0])*(structure_two.positions[j][0]-xyz[0])
-                               +(structure_two.positions[j][1]-xyz[1])*(structure_two.positions[j][1]-xyz[1])
-                               +(structure_two.positions[j][2]-xyz[2])*(structure_two.positions[j][2]-xyz[2]))
-
-        if distance_square > temp_distance_square and structure_one.symbols[i] == structure_two.symbols[j]:
-            distance_square = temp_distance_square
-            temp_index = j
-
-    structure_two_indices.append(temp_index)
-    square_deviations.append(distance_square)
-
-print("Atoms that differ in position:")
-print_non_zeros(square_deviations, structure_two_indices, filter_cutoff)
